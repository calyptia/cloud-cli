package main

import (
	"errors"
	"fmt"
	"regexp"
	"time"

	rateLimiter "golang.org/x/time/rate"

	"github.com/spf13/cobra"

	"os"
	"strings"

	"github.com/calyptia/cli/gcp"
	"github.com/calyptia/core-images-index/go-index"
)

const OperationConcluded = "DONE"

func newCmdCreateCoreInstanceOnGCP(config *config, client gcp.Client) *cobra.Command {

	var (
		coreInstanceName      string
		zone                  string
		projectID             string
		machineType           string
		environment           string
		tags                  []string
		noHealthCheckPipeline bool
		coreInstanceVersion   string
		externalIP            string
		sshKeyPath            string
		sshUser               string
		network               string
		githubToken           string
		useTestImages         bool
		credentials           string
		rateLimit             time.Duration
	)
	cmd := &cobra.Command{
		Use:     "gcp",
		Aliases: []string{"google", "gce"},
		Short:   "Setup a new core instance on Google Compute Engine",
		Long:    "Setup a new core instance on Google Compute Engine, you need to be authenticated with gcloud cli",
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx := cmd.Context()
			gcpImage, err := index.NewGCP()
			if err != nil {
				return err
			}

			if coreInstanceVersion != "" && coreInstanceVersion != "latest" {
				location, err := extractLocation(zone)
				if err != nil {
					return err
				}
				coreInstanceVersion, err = gcpImage.Match(ctx, index.FilterOpts{
					Region:    location,
					Version:   coreInstanceVersion,
					TestIndex: useTestImages,
				})
				if err != nil {
					return err
				}
			}

			if client == nil {
				client, err = gcp.New(ctx, projectID, environment, credentials)
				if err != nil {
					return fmt.Errorf("could not initialize GCP client: %w", err)
				}
			}

			newConfig := gcp.NewConfig(projectID, coreInstanceName, environment)

			if useTestImages && githubToken == "" {
				return errors.New("github token required when using test images")
			} else {
				newConfig.SetGitHubToken(githubToken)
			}

			newConfig.SetZone(zone).
				SetMachineType(machineType).
				SetName(coreInstanceName).
				SetTags(tags).
				SetImage(coreInstanceVersion).
				SetEnvironment(environment).
				SetProjectToken(config.projectToken).
				SetAggregator(coreInstanceName).
				SetIP(externalIP).
				SetSSHKey(sshUser, sshKeyPath).
				SetNetwork(network)

			client.SetConfig(newConfig)

			err = client.Deploy(ctx)
			if err != nil {
				return fmt.Errorf("could not create deployment: %w", err)
			}

			_, err = client.FollowOperations(ctx)
			if err != nil {
				return fmt.Errorf("could not get operation: %w", err)
			}

			cmd.Printf("[*] Waiting for create operation...")

			rateLimit := rateLimiter.Every(1 * time.Minute / rateLimit)
			limiter := rateLimiter.NewLimiter(rateLimit, burstNumber)
			for {
				if err := limiter.Wait(ctx); err != nil {
					return err
				}

				operation, err := client.FollowOperations(ctx)
				if err != nil {
					cmd.PrintErr(err)
					cmd.Println("A problem occurred while creating the instance, a rollback will be performed...")
					err = client.Rollback(ctx)
					if err != nil {
						return fmt.Errorf("rollback operation: %w", err)
					}

					cmd.Println("Rollback successful")
					return nil
				}

				if operation.Status == OperationConcluded {
					cmd.Println("done.")
					break
				}
			}

			instance, err := client.GetInstance(ctx, zone, coreInstanceName)
			if err != nil {
				cmd.PrintErrf("could not find the created instance")
				return nil
			}
			internalIP := "N/A"
			if instance.NetworkInterfaces[0] != nil {
				internalIP = instance.NetworkInterfaces[0].NetworkIP
			}
			externalIP := "N/A"
			if instance.NetworkInterfaces[0] != nil && instance.NetworkInterfaces[0].AccessConfigs[0] != nil {
				externalIP = instance.NetworkInterfaces[0].AccessConfigs[0].NatIP
			}
			cmd.Printf("[*] Calyptia Core Instance created.\nExternal IP: %s\nInternal IP: %s", externalIP, internalIP)

			return nil
		},
	}
	fs := cmd.Flags()
	fs.StringSliceVar(&tags, "tags", nil, "Tags to apply to the core instance")
	fs.StringVar(&coreInstanceVersion, "version", "latest", "Core instance version")
	fs.StringVar(&environment, "environment", "default", "Calyptia environment name")
	fs.BoolVar(&noHealthCheckPipeline, "no-health-check-pipeline", false, "Disable health check pipeline creation alongside the core instance")
	fs.StringVar(&coreInstanceName, "name", "", "Core instance name (autogenerated if empty)")
	fs.StringVar(&projectID, "project-id", "", "GCP project ID")
	fs.StringVar(&zone, "zone", gcp.DefaultZone, "GCP zone name to use in the instance.")
	fs.StringVar(&machineType, "machine-type", gcp.DefaultMachineType, "GCP Instance type to use (see https://cloud.google.com/compute/docs/general-purpose-machines) for details.")
	fs.StringVar(&externalIP, "external-ip", "", "GCP external IP address to use for the instance. (default is ephemeral)")
	fs.StringVar(&sshUser, "ssh-user", "", "GCP SSH user to use for the instance. (default is no user)")
	fs.StringVar(&sshKeyPath, "ssh-key", "", "SSH Key path to use for the instance. (default is no key)")
	fs.StringVar(&network, "network", "default", "GCP Network")
	fs.StringVar(&githubToken, "github-token", os.Getenv("GITHUB_TOKEN"), "GitHub token for test purposes")
	fs.BoolVar(&useTestImages, "use-test-images", envBool("CALYPTIA_USE_TEST_IMAGES"), "Use GCP test images instead of released channel (only for testing/development).")
	fs.StringVar(&credentials, "credentials", os.Getenv("GOOGLE_APPLICATION_CREDENTIALS"), "Path to GCP credentials file. (default is $GOOGLE_APPLICATION_CREDENTIALS)")
	fs.DurationVar(&rateLimit, "request-per-minute", 20, "Rate limit for operations")

	_ = fs.MarkHidden("request-per-minute")
	_ = fs.MarkHidden("github-token")
	_ = fs.MarkHidden("use-test-images")

	return cmd
}

func envBool(key string) bool {
	return strings.EqualFold(os.Getenv(key), "true")
}

func extractLocation(zone string) (string, error) {
	compile, err := regexp.Compile(`^(\w+)`)
	if err != nil {
		return "", fmt.Errorf("an error occured parsing the location")
	}
	return compile.FindString(zone), nil
}
